<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pocket TTS - Dual Panels</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
        .spinner { animation: spin 1s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div class="max-w-5xl mx-auto p-4 space-y-4">
        <h1 class="text-xl font-bold text-center">Pocket TTS</h1>

        <!-- Shared voice controls -->
        <div class="bg-white p-4 rounded-lg shadow">
            <p class="text-sm text-gray-700 font-medium mb-3">Shared voice settings (used by both panels)</p>
            <label for="voice-url-input" class="block text-sm font-medium text-gray-700 mb-2">
                Optional voice URL (leave empty to use default voice):
            </label>
            <input
                type="text"
                id="voice-url-input"
                class="w-full border rounded p-2"
                placeholder="hf://kyutai/tts-voices/alba-mackenna/casual.wav"
                value="alba"
            />
            <p class="text-xs text-gray-500 mt-1">
                Supports: http://, https://, or hf:// URLs.<br>
                You can also use predefined voices:<br>
                "alba", "marius", "javert", "jean", "fantine", "cosette", "eponine", "azelma".
            </p>

            <div class="mt-4">
                <label for="voice-wav-input" class="block text-sm font-medium text-gray-700 mb-2">
                    Or upload a WAV file for voice cloning (takes precedence over URL):
                </label>
                <input
                    type="file"
                    id="voice-wav-input"
                    class="w-full border rounded p-2"
                    accept=".wav,audio/wav"
                />
            </div>
        </div>

        <!-- Panels grid -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <!-- Left Panel -->
            <div class="bg-white p-4 rounded-lg shadow space-y-3" id="left-panel">
                <h2 class="text-lg font-semibold">Panel 1</h2>
                <textarea
                    id="left-text-input"
                    class="w-full border rounded p-2"
                    placeholder="Enter your text here..."
                    rows="4"
                >Hello world. I am Kyutai's Pocket TTS. I'm fast enough to run on small CPUs. I hope you'll like me.</textarea>

                <button
                    id="left-generate-btn"
                    class="w-full px-4 py-2 rounded text-white bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
                >
                    <span id="left-generate-text">Generate Audio (Panel 1)</span>
                </button>

                <div id="left-status" class="hidden">
                    <div class="flex items-center space-x-2">
                        <div id="left-status-spinner" class="spinner w-4 h-4 border-2 border-blue-600 border-t-transparent rounded-full"></div>
                        <span id="left-status-text"></span>
                    </div>
                </div>

                <div id="left-audio-section" class="hidden">
                    <h3 class="text-base font-semibold mb-2">Generated Audio (Panel 1)</h3>
                    <audio id="left-audio" controls class="w-full"></audio>
                    <div class="mt-2">
                        <a id="left-download-link" class="text-blue-600 text-sm hover:underline">Download</a>
                    </div>
                </div>
            </div>

            <!-- Right Panel -->
            <div class="bg-white p-4 rounded-lg shadow space-y-3" id="right-panel">
                <h2 class="text-lg font-semibold">Panel 2</h2>
                <textarea
                    id="right-text-input"
                    class="w-full border rounded p-2"
                    placeholder="Enter your text here..."
                    rows="4"
                >This is the second panel. You can enter different text here and generate another audio.</textarea>

                <button
                    id="right-generate-btn"
                    class="w-full px-4 py-2 rounded text-white bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
                >
                    <span id="right-generate-text">Generate Audio (Panel 2)</span>
                </button>

                <div id="right-status" class="hidden">
                    <div class="flex items-center space-x-2">
                        <div id="right-status-spinner" class="spinner w-4 h-4 border-2 border-blue-600 border-t-transparent rounded-full"></div>
                        <span id="right-status-text"></span>
                    </div>
                </div>

                <div id="right-audio-section" class="hidden">
                    <h3 class="text-base font-semibold mb-2">Generated Audio (Panel 2)</h3>
                    <audio id="right-audio" controls class="w-full"></audio>
                    <div class="mt-2">
                        <a id="right-download-link" class="text-blue-600 text-sm hover:underline">Download</a>
                    </div>
                </div>
            </div>
        </div>

        <!-- Generate both (sequential) -->
        <div class="bg-white p-4 rounded-lg shadow">
            <button
                id="generate-both-btn"
                class="w-full px-4 py-2 rounded text-white bg-indigo-600 hover:bg-indigo-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
            >
                Generate Both (Sequential)
            </button>
            <p class="text-xs text-gray-500 mt-2">
                Note: generation runs sequentially to avoid concurrent model use.
            </p>

            <div id="combined-audio-section" class="hidden mt-4">
                <h3 class="text-base font-semibold mb-2">Combined Audio (Panel 1 + Panel 2)</h3>
                <audio id="combined-audio" controls class="w-full"></audio>
                <div class="mt-2">
                    <a id="combined-download-link" class="text-blue-600 text-sm hover:underline">Download Combined</a>
                </div>
            </div>
        </div>
    </div>

    <script>
        class StreamingWavPlayer {
            constructor(onFirstAudio) {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.sampleRate = 0;
                this.numChannels = 0;
                this.headerParsed = false;
                this.headerBuffer = new Uint8Array(44);
                this.headerBytesReceived = 0;
                this.nextStartTime = 0;
                this.isPlaying = false;
                this.minBufferSize = 16384;
                this.pcmData = new Uint8Array(0);
                this.firstAudioPlayed = false;
                this.onFirstAudio = onFirstAudio;
            }

            parseWavHeader(header) {
                const view = new DataView(header.buffer);
                const riff = String.fromCharCode.apply(null, Array.from(header.slice(0, 4)));
                const wave = String.fromCharCode.apply(null, Array.from(header.slice(8, 12)));
                if (riff !== 'RIFF' || wave !== 'WAVE') throw new Error('Invalid WAV file');
                this.numChannels = view.getUint16(22, true);
                this.sampleRate = view.getUint32(24, true);
                const bitsPerSample = view.getUint16(34, true);
                console.log(`WAV Format: ${this.sampleRate}Hz, ${this.numChannels} channels, ${bitsPerSample} bits`);
                this.headerParsed = true;
            }

            appendPcmData(newData) {
                const newBuffer = new Uint8Array(this.pcmData.length + newData.length);
                newBuffer.set(this.pcmData);
                newBuffer.set(newData, this.pcmData.length);
                this.pcmData = newBuffer;
            }

            async tryPlayBuffer() {
                if (!this.headerParsed || this.pcmData.length < this.minBufferSize) return;
                const bytesPerSample = this.numChannels * 2;
                const samplesToPlay = Math.floor(this.pcmData.length / bytesPerSample);
                const bytesToPlay = samplesToPlay * bytesPerSample;
                if (bytesToPlay === 0) return;

                const dataToPlay = this.pcmData.slice(0, bytesToPlay);
                this.pcmData = this.pcmData.slice(bytesToPlay);

                const audioBuffer = this.audioContext.createBuffer(this.numChannels, samplesToPlay, this.sampleRate);
                const int16Data = new Int16Array(dataToPlay.buffer, dataToPlay.byteOffset, samplesToPlay * this.numChannels);
                for (let channel = 0; channel < this.numChannels; channel++) {
                    const channelData = audioBuffer.getChannelData(channel);
                    for (let i = 0; i < samplesToPlay; i++) {
                        channelData[i] = int16Data[i * this.numChannels + channel] / 32768;
                    }
                }

                const source = this.audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(this.audioContext.destination);

                const currentTime = this.audioContext.currentTime;
                const startTime = Math.max(currentTime, this.nextStartTime);
                source.start(startTime);

                if (!this.firstAudioPlayed && this.onFirstAudio) {
                    this.firstAudioPlayed = true;
                    try { this.onFirstAudio(); } catch (_) {}
                }

                this.nextStartTime = startTime + audioBuffer.duration;
                this.isPlaying = true;

                if (this.pcmData.length >= this.minBufferSize) {
                    setTimeout(() => this.tryPlayBuffer(), 10);
                }
            }

            addChunk(chunk) {
                if (!this.headerParsed) {
                    const headerBytesNeeded = 44 - this.headerBytesReceived;
                    const bytesToCopy = Math.min(headerBytesNeeded, chunk.length);
                    this.headerBuffer.set(chunk.slice(0, bytesToCopy), this.headerBytesReceived);
                    this.headerBytesReceived += bytesToCopy;
                    if (this.headerBytesReceived >= 44) {
                        this.parseWavHeader(this.headerBuffer);
                        if (chunk.length > bytesToCopy) this.appendPcmData(chunk.slice(bytesToCopy));
                    }
                } else {
                    this.appendPcmData(chunk);
                }
                this.tryPlayBuffer();
            }

            stop() {
                try { this.audioContext.close(); } catch (_) {}
                this.isPlaying = false;
            }
        }

        // Panel helper
        function getPanelRefs(prefix) {
            return {
                textInput: document.getElementById(`${prefix}-text-input`),
                generateBtn: document.getElementById(`${prefix}-generate-btn`),
                generateText: document.getElementById(`${prefix}-generate-text`),
                status: document.getElementById(`${prefix}-status`),
                statusText: document.getElementById(`${prefix}-status-text`),
                statusSpinner: document.getElementById(`${prefix}-status-spinner`),
                audioSection: document.getElementById(`${prefix}-audio-section`),
                audio: document.getElementById(`${prefix}-audio`),
                downloadLink: document.getElementById(`${prefix}-download-link`),
                streamingPlayer: null,
                currentAudioBlob: null,
            };
        }

        const left = getPanelRefs('left');
        const right = getPanelRefs('right');
        const generateBothBtn = document.getElementById('generate-both-btn');
        const combinedAudioSection = document.getElementById('combined-audio-section');
        const combinedAudio = document.getElementById('combined-audio');
        const combinedDownloadLink = document.getElementById('combined-download-link');

        function showStatus(panel, message, isLoading = false) {
            panel.statusText.textContent = message;
            panel.statusSpinner.style.display = isLoading ? 'block' : 'none';
            panel.status.classList.remove('hidden');
        }
        function hideStatus(panel) { panel.status.classList.add('hidden'); }

        function setAllDisabled(disabled) {
            left.generateBtn.disabled = disabled;
            right.generateBtn.disabled = disabled;
            generateBothBtn.disabled = disabled;
        }

        async function parseWavBlob(blob) {
            const buf = await blob.arrayBuffer();
            if (buf.byteLength < 44) throw new Error('Invalid WAV (too short)');
            const view = new DataView(buf, 0, 44);
            const riff = String.fromCharCode(...new Uint8Array(buf, 0, 4));
            const wave = String.fromCharCode(...new Uint8Array(buf, 8, 4));
            if (riff !== 'RIFF' || wave !== 'WAVE') throw new Error('Invalid WAV file');
            const numChannels = view.getUint16(22, true);
            const sampleRate = view.getUint32(24, true);
            const bitsPerSample = view.getUint16(34, true);
            const pcmBytes = new Uint8Array(buf, 44);
            return { numChannels, sampleRate, bitsPerSample, pcmBytes };
        }

        function buildWavBlobFromPcm(pcmBytes, sampleRate, numChannels, bitsPerSample = 16) {
            const blockAlign = numChannels * (bitsPerSample / 8);
            const byteRate = sampleRate * blockAlign;
            const dataSize = pcmBytes.length;
            const header = new ArrayBuffer(44);
            const dv = new DataView(header);
            const u8 = new Uint8Array(header);
            const writeStr = (offset, str) => { for (let i = 0; i < str.length; i++) u8[offset + i] = str.charCodeAt(i); };

            writeStr(0, 'RIFF');
            dv.setUint32(4, 36 + dataSize, true);
            writeStr(8, 'WAVE');
            writeStr(12, 'fmt ');
            dv.setUint32(16, 16, true); // Subchunk1Size for PCM
            dv.setUint16(20, 1, true);  // AudioFormat PCM
            dv.setUint16(22, numChannels, true);
            dv.setUint32(24, sampleRate, true);
            dv.setUint32(28, byteRate, true);
            dv.setUint16(32, blockAlign, true);
            dv.setUint16(34, bitsPerSample, true);
            writeStr(36, 'data');
            dv.setUint32(40, dataSize, true);

            return new Blob([header, pcmBytes], { type: 'audio/wav' });
        }
        async function generate(panel, label) {
            const text = panel.textInput.value.trim();
            if (!text) {
                showStatus(panel, 'Please enter some text to generate speech.', false);
                setTimeout(() => hideStatus(panel), 3000);
                return;
            }

            // Stop any currently playing audio in this panel
            if (panel.streamingPlayer) { panel.streamingPlayer.stop(); panel.streamingPlayer = null; }

            const startTime = performance.now();
            let firstAudioTime = null;

            const onFirstAudio = () => {
                if (!firstAudioTime) {
                    firstAudioTime = performance.now();
                    const tfa = ((firstAudioTime - startTime) / 1000).toFixed(2);
                    showStatus(panel, `First audio in ${tfa}s...`, true);
                }
            };

            // Update UI
            panel.generateBtn.disabled = true;
            const originalBtnText = panel.generateText.textContent;
            panel.generateText.textContent = 'Generating...';
            showStatus(panel, 'Generating speech...', true);
            panel.audioSection.classList.add('hidden');
            setAllDisabled(true); // lock other actions while generating

            try {
                const formData = new FormData();
                formData.append('text', text);

                // Shared voice controls
                const voiceUrl = document.getElementById('voice-url-input').value.trim();
                const voiceWavFile = document.getElementById('voice-wav-input').files[0];
                if (voiceWavFile) {
                    formData.append('voice_wav', voiceWavFile);
                } else if (voiceUrl) {
                    formData.append('voice_url', voiceUrl);
                }

                const response = await fetch('/tts', { method: 'POST', body: formData });
                if (!response.ok) throw new Error(`Server error: ${response.status}`);

                const responseForPlayback = response.clone();
                const responseForHistory = response.clone();

                const reader = responseForPlayback.body.getReader();
                panel.streamingPlayer = new StreamingWavPlayer(onFirstAudio);

                (async () => {
                    try {
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            if (value) panel.streamingPlayer.addChunk(value);
                        }
                    } catch (e) { console.error('Error processing stream:', e); }
                })();

                const blob = await responseForHistory.blob();
                const totalTime = ((performance.now() - startTime) / 1000).toFixed(2);
                panel.currentAudioBlob = blob;

                const audioUrl = URL.createObjectURL(blob);
                panel.audio.src = audioUrl;

                panel.audio.addEventListener('loadedmetadata', () => {
                    const audioDuration = panel.audio.duration;
                    const speedRatio = (audioDuration / parseFloat(totalTime)).toFixed(1);
                    const timeToFirst = firstAudioTime ? ((firstAudioTime - startTime) / 1000).toFixed(2) : 'N/A';
                    showStatus(panel, `âœ¨ First audio: ${timeToFirst}s | Total: ${totalTime}s | ${speedRatio}x faster than real-time`, false);
                }, { once: true });

                panel.downloadLink.href = audioUrl;
                panel.downloadLink.download = `${label}-tts-audio.wav`;
                panel.audioSection.classList.remove('hidden');
                return blob;
            } catch (error) {
                console.error('Error generating audio:', error);
                showStatus(panel, `Error: ${error.message}`, false);
                setTimeout(() => hideStatus(panel), 3000);
            } finally {
                panel.generateBtn.disabled = false;
                panel.generateText.textContent = originalBtnText;
                setAllDisabled(false);
            }
        }

        // Event listeners
        left.generateBtn.addEventListener('click', () => generate(left, 'panel1'));
        right.generateBtn.addEventListener('click', () => generate(right, 'panel2'));
        generateBothBtn.addEventListener('click', async () => {
            setAllDisabled(true);
            try {
                const leftBlob = await generate(left, 'panel1');
                const rightBlob = await generate(right, 'panel2');
                if (!leftBlob || !rightBlob) return;

                const leftWav = await parseWavBlob(leftBlob);
                const rightWav = await parseWavBlob(rightBlob);

                if (leftWav.sampleRate !== rightWav.sampleRate || leftWav.numChannels !== rightWav.numChannels) {
                    console.warn('Mismatched WAV formats; cannot combine.');
                    return;
                }

                const combinedPcm = new Uint8Array(leftWav.pcmBytes.length + rightWav.pcmBytes.length);
                combinedPcm.set(leftWav.pcmBytes, 0);
                combinedPcm.set(rightWav.pcmBytes, leftWav.pcmBytes.length);

                const combinedBlob = buildWavBlobFromPcm(
                    combinedPcm,
                    leftWav.sampleRate,
                    leftWav.numChannels,
                    leftWav.bitsPerSample
                );

                const url = URL.createObjectURL(combinedBlob);
                combinedAudio.src = url;
                combinedDownloadLink.href = url;
                combinedDownloadLink.download = 'combined-tts-audio.wav';
                combinedAudioSection.classList.remove('hidden');
            } finally {
                setAllDisabled(false);
            }
        });

        // Focus on left text input when page loads
        window.addEventListener('load', () => { left.textInput.focus(); });
    </script>
</body>
</html>